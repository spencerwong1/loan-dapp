<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loan DApp - Decentralized lending platform</title>
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #2c3e50;
      background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
      min-height: 100vh;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }

    .header {
      text-align: center;
      background: white;
      border-radius: 16px;
      padding: 32px 24px;
      margin-bottom: 32px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      border: 1px solid #e2e8f0;
    }

    .header h1 {
      font-size: 2.5rem;
      margin-bottom: 12px;
      color: #1e293b;
      font-weight: 700;
      letter-spacing: -0.025em;
    }

    .header p {
      font-size: 1.125rem;
      color: #64748b;
      font-weight: 500;
    }

    .dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 24px;
      margin-bottom: 32px;
    }

    .stat-card {
      background: white;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      border: 1px solid #e2e8f0;
      text-align: left;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .stat-card:hover {
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
      border-color: #cbd5e1;
    }

    .stat-card h3 {
      color: #475569;
      margin-bottom: 8px;
      font-size: 0.875rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .stat-value {
      font-size: 2.25rem;
      font-weight: 700;
      color: #0f172a;
      line-height: 1.2;
    }

    .section {
      background: white;
      margin-bottom: 32px;
      border-radius: 12px;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      border: 1px solid #e2e8f0;
      overflow: hidden;
    }

    .section-header {
      background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      color: white;
      padding: 24px 32px;
      font-size: 1.25rem;
      font-weight: 600;
      letter-spacing: -0.025em;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .section-content {
      padding: 32px;
    }

    .form-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .form-group {
      display: flex;
      flex-direction: column;
    }

    .form-group label {
      margin-bottom: 8px;
      font-weight: 600;
      color: #374151;
      font-size: 0.875rem;
      letter-spacing: -0.025em;
    }

    input[type="text"], input[type="number"], select {
      padding: 12px 16px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      font-size: 14px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      background: white;
      color: #374151;
    }

    input[type="text"]:focus, input[type="number"]:focus, select:focus {
      outline: none;
      border-color: #0f172a;
      box-shadow: 0 0 0 3px rgba(15, 23, 42, 0.1);
    }

    .btn {
      background: #0f172a;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
      letter-spacing: -0.025em;
    }

    .btn:hover {
      background: #1e293b;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
      transform: translateY(-1px);
    }

    .btn:active {
      transform: translateY(0);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
    }

    .btn-danger {
      background: #dc2626;
      color: white;
    }

    .btn-danger:hover {
      background: #b91c1c;
      box-shadow: 0 4px 6px rgba(220, 38, 38, 0.2), 0 2px 4px rgba(220, 38, 38, 0.1);
    }

    .loan-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(420px, 1fr));
      gap: 24px;
    }

    .loan-card {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      overflow: hidden;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      background: white;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
    }

    .loan-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.07), 0 2px 4px rgba(0, 0, 0, 0.06);
      border-color: #cbd5e1;
    }

    .loan-header {
      padding: 20px 24px;
      font-weight: 600;
      color: white;
      font-size: 1rem;
      letter-spacing: -0.025em;
    }

    .loan-header.active { 
      background: linear-gradient(135deg, #059669 0%, #047857 100%); 
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .loan-header.repaid { 
      background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%); 
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    .loan-header.defaulted { 
      background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%); 
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .loan-body {
      padding: 24px;
    }

    .loan-details {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 20px;
    }

    .detail-item {
      display: flex;
      justify-content: space-between;
      padding: 12px 0;
      border-bottom: 1px solid #f1f5f9;
    }

    .detail-label {
      font-weight: 600;
      color: #64748b;
      font-size: 0.875rem;
    }

    .detail-value {
      color: #0f172a;
      font-weight: 600;
      font-size: 0.875rem;
    }

    .progress-bar {
      background: #f1f5f9;
      height: 24px;
      border-radius: 12px;
      overflow: hidden;
      margin: 16px 0;
      border: 1px solid #e2e8f0;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #059669, #047857);
      transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 12px;
      font-weight: 600;
      letter-spacing: -0.025em;
    }

    .time-info {
      background: #f8fafc;
      padding: 20px;
      border-radius: 8px;
      margin: 20px 0;
      border: 1px solid #e2e8f0;
    }

    .time-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    .installment-schedule {
      background: #f8fafc;
      padding: 16px;
      border-radius: 8px;
      margin: 20px 0;
      max-height: 320px;
      overflow-y: auto;
      position: relative;
      border: 1px solid #e2e8f0;
    }

    .installment-schedule::-webkit-scrollbar {
      width: 8px;
    }

    .installment-schedule::-webkit-scrollbar-track {
      background: #e9ecef;
      border-radius: 4px;
    }

    .installment-schedule::-webkit-scrollbar-thumb {
      background: #667eea;
      border-radius: 4px;
    }

    .installment-schedule::-webkit-scrollbar-thumb:hover {
      background: #5a6fd8;
    }

    .installment-schedule-header {
      position: sticky;
      top: 0;
      background: #f8f9fa;
      padding-bottom: 10px;
      margin-bottom: 10px;
      border-bottom: 2px solid #e9ecef;
      font-weight: bold;
      z-index: 1;
    }

    .installment-container {
      max-height: 240px;
      overflow-y: auto;
      scroll-behavior: smooth;
      padding-right: 5px;
    }

    .installment-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      margin-bottom: 8px;
      background: #fff;
      border-radius: 6px;
      border: 1px solid #e9ecef;
      transition: all 0.2s ease;
    }

    .installment-item:hover {
      transform: translateX(2px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .installment-item:last-child {
      margin-bottom: 0;
    }

    /* Mobile responsiveness for installment schedule */
    @media (max-width: 768px) {
      .installment-schedule {
        max-height: 250px;
      }
      
      .installment-container {
        max-height: 190px;
      }
      
      .installment-item {
        padding: 10px;
        flex-direction: column;
        align-items: flex-start;
        gap: 5px;
      }
      
      .installment-item > div {
        width: 100%;
      }
    }

    /* Scrollbar styles for Firefox */
    .installment-schedule {
      scrollbar-width: thin;
      scrollbar-color: #667eea #e9ecef;
    }

    /* Add fade effect at bottom when scrollable */
    .installment-schedule::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 20px;
      background: linear-gradient(transparent, #f8f9fa);
      pointer-events: none;
      border-radius: 0 0 8px 8px;
    }

    .installment-due { color: #dc2626; font-weight: bold; }
    .installment-paid { color: #059669; }
    .installment-upcoming { color: #64748b; }

    /* Time remaining classes */
    .overdue { 
      color: #dc2626; 
      font-weight: bold;
      background: rgba(220, 38, 38, 0.1);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.875rem;
    }
    .critical { 
      color: #dc2626; 
      font-weight: bold;
      animation: pulse 2s infinite;
      background: rgba(220, 38, 38, 0.1);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.875rem;
    }
    .urgent { 
      color: #ea580c; 
      font-weight: bold;
      background: rgba(234, 88, 12, 0.1);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.875rem;
    }
    .soon { 
      color: #d97706; 
      font-weight: 500;
      font-size: 0.875rem;
    }
    .upcoming { 
      color: #64748b; 
      font-size: 0.875rem;
    }

    @keyframes pulse {
      0% { opacity: 1; }
      50% { opacity: 0.6; }
      100% { opacity: 1; }
    }

    .error {
      background: #fef2f2;
      color: #991b1b;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #fecaca;
      border-left: 4px solid #dc2626;
      margin-bottom: 24px;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .success {
      background: #f0fdf4;
      color: #166534;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #bbf7d0;
      border-left: 4px solid #059669;
      margin-bottom: 24px;
      font-size: 0.875rem;
      font-weight: 500;
    }

    .filters {
      display: flex;
      gap: 12px;
      margin-bottom: 24px;
      flex-wrap: wrap;
    }

    .filter-btn {
      padding: 10px 20px;
      border: 1px solid #d1d5db;
      background: white;
      color: #6b7280;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 14px;
      font-weight: 500;
      letter-spacing: -0.025em;
    }

    .filter-btn.active {
      background: #0f172a;
      color: white;
      border-color: #0f172a;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
    }

    .filter-btn:hover:not(.active) {
      background: #f9fafb;
      border-color: #9ca3af;
      color: #374151;
    }

    .loading {
      text-align: center;
      padding: 40px;
      color: #666;
    }

    .address {
      font-family: 'Courier New', monospace;
      font-size: 0.9em;
      background: #f0f0f0;
      padding: 2px 6px;
      border-radius: 4px;
    }

    .address-clickable {
      font-family: 'SF Mono', 'Monaco', 'Consolas', 'Liberation Mono', 'Courier New', monospace;
      font-size: 0.875rem;
      background: #f8fafc;
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      border: 1px solid #e2e8f0;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-weight: 500;
    }

    .address-clickable:hover {
      background: #0f172a;
      color: white;
      border-color: #0f172a;
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(15, 23, 42, 0.1);
    }

    .address-clickable .copy-icon {
      opacity: 0.6;
      font-size: 0.8em;
      transition: opacity 0.2s ease;
    }

    .address-clickable:hover .copy-icon {
      opacity: 1;
    }

    @media (max-width: 768px) {
      .container {
        padding: 10px;
      }
      
      .form-grid {
        grid-template-columns: 1fr;
      }
      
      .loan-grid {
        grid-template-columns: 1fr;
      }
      
      .loan-details {
        grid-template-columns: 1fr;
      }
      
      .time-grid {
        grid-template-columns: 1fr;
      }

      .address-clickable {
        font-size: 0.85em;
        padding: 6px 10px;
        margin: 2px 0;
        touch-action: manipulation;
        -webkit-tap-highlight-color: rgba(102, 126, 234, 0.2);
      }

      .address-clickable:hover {
        /* Override hover effects on mobile to prevent sticky hover */
        background: #f0f0f0;
        color: inherit;
        border-color: transparent;
        transform: none;
        box-shadow: none;
      }

      .address-clickable:active {
        background: #667eea;
        color: white;
        border-color: #5a6fd8;
        transform: scale(0.98);
      }
    }
  </style>
</head>
<body>
  <div class="container">
        <div class="header">
      <h1>üè¶ Loan DApp</h1>
      <p>Decentralized Peer-to-Peer Lending Platform</p>
      <div id="networkStatus" style="margin-top: 16px; padding: 8px 16px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 8px; font-size: 0.875rem; color: #64748b;">
        üîó Connecting...
  </div>
  </div>

                <div class="dashboard" id="dashboard">
      <div class="stat-card">
        <h3>Your Balance</h3>
        <div class="stat-value" id="userBalance">- MTK</div>
      </div>
      <div class="stat-card">
        <h3>Your Total Loans</h3>
        <div class="stat-value" id="totalLoans">-</div>
      </div>
      <div class="stat-card">
        <h3>Your Active Loans</h3>
        <div class="stat-value" id="activeLoans">-</div>
      </div>
      <div class="stat-card">
        <h3>Your Trust Score</h3>
        <div class="stat-value" id="userTrustScore">-</div>
      </div>
    </div>

    <div id="error" class="error" style="display: none;"></div>
    <div id="success" class="success" style="display: none;"></div>

  <div class="section">
      <div class="section-header">üìù Create New Loan</div>
      <div class="section-content">
        <div class="form-grid">
          <div class="form-group">
            <label for="borrower">Borrower Address</label>
            <input id="borrower" placeholder="0x..." type="text">
  </div>
          <div class="form-group">
            <label for="amount">Loan Amount</label>
            <input id="amount" placeholder="100" type="number" min="1">
          </div>
          <div class="form-group">
            <label for="token">Token Address</label>
            <input id="token" type="text" value="0xE20F9c547C09f6259003c127765865F5c55dB40C">
          </div>
          <div class="form-group">
            <label for="duration">Duration (days)</label>
            <input id="duration" placeholder="30" type="number" min="1">
          </div>
          <div class="form-group">
            <label for="interest">Interest Rate (%)</label>
            <input id="interest" placeholder="5" type="number" min="0" step="0.1">
          </div>
          <div class="form-group">
            <label for="lateFee">Late Fee Rate (%)</label>
            <input id="lateFee" placeholder="2" type="number" min="0" step="0.1">
          </div>
          <div class="form-group">
            <label for="installments">Number of Installments</label>
            <input id="installments" placeholder="3" type="number" min="1">
          </div>
        </div>
        <button class="btn" onclick="createLoan()">
          üöÄ Create Loan
        </button>
      </div>
    </div>

    <!-- Global Loan Controls -->
  <div class="section">
      <div class="section-header">üéõÔ∏è Loan Management Controls</div>
      <div class="section-content" style="text-align: center; padding: 20px;">
        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
          <button class="btn" onclick="refreshLoanData()" title="Refresh all loan data to update totals and late fees" style="font-size: 0.9rem; padding: 12px 20px;">
            üîÑ Refresh All Loans
          </button>
          <button class="btn" onclick="showPendingPenalties()" title="Show pending late payment penalties across all loans (no gas required)" style="background: #3498db; font-size: 0.9rem; padding: 12px 20px;">
            üëÅÔ∏è Check Pending Penalties
          </button>
          <button class="btn" onclick="showTrustScores()" title="View trust scores for all participants" style="background: #9b59b6; font-size: 0.9rem; padding: 12px 20px;">
            üìä View Trust Scores
          </button>
          <button class="btn" onclick="manualRefreshBalances()" title="Force refresh all wallet balances" style="background: #e67e22; font-size: 0.9rem; padding: 12px 20px;">
            üí∞ Refresh Balances
          </button>
  </div>
        <p style="margin-top: 15px; color: #666; font-size: 0.85rem;">
          üí° These controls work across all loan sections and require no gas fees
        </p>
      </div>
    </div>

  <div class="section">
      <div class="section-header">üè¶ Loans Where You Are The Lender</div>
      <div class="section-content">
        <div class="filters">
          <div class="filter-btn active" onclick="filterLenderLoans('all')">All</div>
          <div class="filter-btn" onclick="filterLenderLoans('active')">Active</div>
          <div class="filter-btn" onclick="filterLenderLoans('repaid')">Repaid</div>
          <div class="filter-btn" onclick="filterLenderLoans('defaulted')">Defaulted</div>
  </div>
        <div class="loading" id="lenderLoansLoading">
          <p>Loading your lending portfolio...</p>
        </div>
        <div class="loan-grid" id="lenderLoansGrid" style="display: none;"></div>
        <div id="noLenderLoans" style="display: none; text-align: center; padding: 40px; color: #666;">
          <h3>üíº No Lending Activity</h3>
          <p>You haven't lent any money yet. Create a loan above to start lending!</p>
        </div>
      </div>
    </div>

  <div class="section">
      <div class="section-header">üë§ Loans Where You Are The Borrower</div>
      <div class="section-content">
        <div class="filters">
          <div class="filter-btn active" onclick="filterBorrowerLoans('all')">All</div>
          <div class="filter-btn" onclick="filterBorrowerLoans('active')">Active</div>
          <div class="filter-btn" onclick="filterBorrowerLoans('repaid')">Repaid</div>
          <div class="filter-btn" onclick="filterBorrowerLoans('defaulted')">Defaulted</div>
  </div>
        <div class="loading" id="borrowerLoansLoading">
          <p>Loading your borrowing history...</p>
        </div>
        <div class="loan-grid" id="borrowerLoansGrid" style="display: none;"></div>
        <div id="noBorrowerLoans" style="display: none; text-align: center; padding: 40px; color: #666;">
          <h3>üìã No Borrowing Activity</h3>
          <p>You haven't borrowed any money yet. Someone needs to create a loan with you as the borrower!</p>
        </div>
      </div>
    </div>

  <div class="section">
      <div class="section-header">üåê All Other Loans</div>
      <div class="section-content">
        <div class="filters">
          <div class="filter-btn active" onclick="filterOtherLoans('all')">All</div>
          <div class="filter-btn" onclick="filterOtherLoans('active')">Active</div>
          <div class="filter-btn" onclick="filterOtherLoans('repaid')">Repaid</div>
          <div class="filter-btn" onclick="filterOtherLoans('defaulted')">Defaulted</div>
  </div>
        <div class="loading" id="otherLoansLoading">
          <p>Loading other loans...</p>
        </div>
        <div class="loan-grid" id="otherLoansGrid" style="display: none;"></div>
        <div id="noOtherLoans" style="display: none; text-align: center; padding: 40px; color: #666;">
          <h3>üìä No Other Loans</h3>
          <p>No loans from other users yet!</p>
        </div>
      </div>
    </div>

  <div class="section">
      <div class="section-header">üí∞ Quick Actions</div>
      <div class="section-content">
        <div class="form-grid">
          <div class="form-group">
            <label for="repayLoanAddress">Repay Loan</label>
            <input id="repayLoanAddress" placeholder="Loan Contract Address" type="text">
            <input id="repayAmount" placeholder="Repayment Amount" type="number" min="0.01" step="0.01">
            <button class="btn" onclick="repayLoan()">üí∏ Make Payment</button>
          </div>
          <div class="form-group">
            <label for="defaultLoanAddress">Mark Loan as Default</label>
            <input id="defaultLoanAddress" placeholder="Loan Contract Address" type="text">
            <button class="btn btn-danger" onclick="markDefault()">‚ö†Ô∏è Mark Default</button>
          </div>
          <div class="form-group">
            <label for="trustAddress">Check Trust Score</label>
    <input id="trustAddress" placeholder="User Address" type="text">
            <button class="btn" onclick="getTrustScore()">üîç Get Score</button>
            <p id="trustScore" style="margin-top: 10px; font-weight: bold;"></p>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const factoryAddress = '0xcB3De0b3d9D4DB35d23fd41282eD15e136B5FaE3';
    const LoanFactoryABI = [
            {
            "anonymous": false,
            "inputs": [
                {
                "indexed": true,
                "internalType": "address",
                "name": "borrower",
                "type": "address"
                },
                {
                "indexed": true,
                "internalType": "address",
                "name": "lender",
                "type": "address"
                },
                {
                "indexed": false,
                "internalType": "address",
                "name": "loanAddress",
                "type": "address"
                }
            ],
            "name": "LoanCreated",
            "type": "event"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "_borrower",
                "type": "address"
                },
                {
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256"
                },
                {
                "internalType": "address",
                "name": "_token",
                "type": "address"
                },
                {
                "internalType": "uint256",
                "name": "_duration",
                "type": "uint256"
                },
                {
                "internalType": "uint256",
                "name": "_interestPercent",
                "type": "uint256"
                },
                {
                "internalType": "uint256",
                "name": "_lateFeePercent",
                "type": "uint256"
                },
                {
                "internalType": "uint256",
                "name": "_installments",
                "type": "uint256"
                }
            ],
            "name": "createLoan",
            "outputs": [
                {
                "internalType": "address",
                "name": "loanAddress",
                "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "user",
                "type": "address"
                }
            ],
            "name": "getBorrowerLoans",
            "outputs": [
                {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "borrower",
                "type": "address"
                },
                {
                "internalType": "enum LoanAgreement.LoanStatus",
                "name": "status",
                "type": "uint8"
                }
            ],
            "name": "getBorrowerLoansByStatus",
            "outputs": [
                {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "user",
                "type": "address"
                }
            ],
            "name": "getBorrowerLoansCount",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "user",
                "type": "address"
                }
            ],
            "name": "getLenderLoans",
            "outputs": [
                {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "lender",
                "type": "address"
                },
                {
                "internalType": "enum LoanAgreement.LoanStatus",
                "name": "status",
                "type": "uint8"
                }
            ],
            "name": "getLenderLoansByStatus",
            "outputs": [
                {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "user",
                "type": "address"
                }
            ],
            "name": "getLenderLoansCount",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "getLoans",
            "outputs": [
                {
                "internalType": "address[]",
                "name": "",
                "type": "address[]"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "getLoansCount",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "_user",
                "type": "address"
                }
            ],
            "name": "getTrustScore",
            "outputs": [
                {
                "internalType": "int256",
                "name": "",
                "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "name": "isValidLoan",
            "outputs": [
                {
                "internalType": "bool",
                "name": "",
                "type": "bool"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "name": "loans",
            "outputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                },
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "name": "loansByBorrower",
            "outputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                },
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "name": "loansByLender",
            "outputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "name": "trustScores",
            "outputs": [
                {
                "internalType": "int256",
                "name": "",
                "type": "int256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "_borrower",
                "type": "address"
                },
                {
                "internalType": "int256",
                "name": "_val",
                "type": "int256"
                }
            ],
            "name": "updateTrustScore",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
            }
        ];

        const LoanAgreementABI = [
            {
            "inputs": [
                {
                "internalType": "address",
                "name": "_lender",
                "type": "address"
                },
                {
                "internalType": "address",
                "name": "_borrower",
                "type": "address"
                },
                {
                "internalType": "uint256",
                "name": "_amount",
                "type": "uint256"
                },
                {
                "internalType": "address",
                "name": "_token",
                "type": "address"
                },
                {
                "internalType": "uint256",
                "name": "_duration",
                "type": "uint256"
                },
                {
                "internalType": "uint256",
                "name": "_interestPercent",
                "type": "uint256"
                },
                {
                "internalType": "uint256",
                "name": "_lateFeePercent",
                "type": "uint256"
                },
                {
                "internalType": "uint256",
                "name": "_installments",
                "type": "uint256"
                },
                {
                "internalType": "address",
                "name": "_factory",
                "type": "address"
                }
            ],
            "stateMutability": "nonpayable",
            "type": "constructor"
            },
            {
            "anonymous": false,
            "inputs": [
                {
                "indexed": true,
                "internalType": "address",
                "name": "loan",
                "type": "address"
                },
                {
                "indexed": true,
                "internalType": "address",
                "name": "lender",
                "type": "address"
                }
            ],
            "name": "DefaultMarked",
            "type": "event"
            },
            {
            "anonymous": false,
            "inputs": [
                {
                "indexed": true,
                "internalType": "address",
                "name": "loan",
                "type": "address"
                }
            ],
            "name": "FullyRepaid",
            "type": "event"
            },
            {
            "anonymous": false,
            "inputs": [
                {
                "indexed": true,
                "internalType": "address",
                "name": "payer",
                "type": "address"
                },
                {
                "indexed": false,
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
                },
                {
                "indexed": false,
                "internalType": "uint256",
                "name": "totalRepaid",
                "type": "uint256"
                }
            ],
            "name": "Repaid",
            "type": "event"
            },
            {
            "inputs": [],
            "name": "borrower",
            "outputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "countMissedInstallments",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "missed",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "checkAndPenalizeLatePayments",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "dueTimestamp",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "factory",
            "outputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "getDueTimestamp",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "getRepaidAmount",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "getStatus",
            "outputs": [
                {
                "internalType": "enum LoanAgreement.LoanStatus",
                "name": "",
                "type": "uint8"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "getTotalOwed",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "totalOwed",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "installmentInterval",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "interestPercent",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "lateFeePercent",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "lender",
            "outputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "markDefault",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "markedDefault",
            "outputs": [
                {
                "internalType": "bool",
                "name": "",
                "type": "bool"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "principal",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "repaidAmount",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [
                {
                "internalType": "uint256",
                "name": "amount",
                "type": "uint256"
                }
            ],
            "name": "repay",
            "outputs": [],
            "stateMutability": "nonpayable",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "startTimestamp",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "tokenAddress",
            "outputs": [
                {
                "internalType": "address",
                "name": "",
                "type": "address"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            },
            {
            "inputs": [],
            "name": "totalInstallments",
            "outputs": [
                {
                "internalType": "uint256",
                "name": "",
                "type": "uint256"
                }
            ],
            "stateMutability": "view",
            "type": "function"
            }
        ];

        const MockTokenABI = [
      {
        "inputs": [
          { "internalType": "address", "name": "spender", "type": "address" },
          { "internalType": "uint256", "name": "amount", "type": "uint256" }
        ],
        "name": "approve",
        "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [{ "internalType": "address", "name": "account", "type": "address" }],
        "name": "balanceOf",
        "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }],
        "stateMutability": "view",
        "type": "function"
      }
    ];

    let provider, signer, factoryContract, tokenContract;
    let currentLenderFilter = 'all';
    let currentBorrowerFilter = 'all';
    let currentOtherFilter = 'all';
    let allLoans = [];
    let lenderLoans = [];
    let borrowerLoans = [];
    let otherLoans = [];
    let userAddress = null;
    let currentNetwork = null;
    let userBalance = 0;
    let isLoadingLoans = false; // Prevent concurrent loan loading

    async function init() {
      if (typeof window.ethereum !== 'undefined') {
        try {
          provider = new ethers.BrowserProvider(window.ethereum);
          await window.ethereum.request({ method: 'eth_requestAccounts' });
          signer = await provider.getSigner();
          userAddress = await signer.getAddress();
          
          // Check network
          const network = await provider.getNetwork();
          currentNetwork = network;
          console.log("Connected to network:", network.name, "Chain ID:", network.chainId);
          
          // Update network status
          const networkStatus = document.getElementById("networkStatus");
          
          // Check if we're on Sepolia testnet (chain ID 11155111)
          if (network.chainId !== 11155111n) {
            displayError(`‚ùå Wrong Network! Please switch to Sepolia Testnet. Currently on: ${network.name || 'Unknown'} (Chain ID: ${network.chainId})`);
            if (networkStatus) {
              networkStatus.innerHTML = `‚ùå Wrong Network: ${network.name || 'Unknown'}`;
              networkStatus.style.background = 'rgba(244, 67, 54, 0.2)';
            }
            return;
          }
          
          if (networkStatus) {
            networkStatus.innerHTML = `‚úÖ Connected to Sepolia Testnet`;
            networkStatus.style.background = 'rgba(76, 175, 80, 0.2)';
          }
          
          factoryContract = new ethers.Contract(factoryAddress, LoanFactoryABI, signer);
          tokenContract = new ethers.Contract('0xE20F9c547C09f6259003c127765865F5c55dB40C', MockTokenABI, signer);
          
          console.log("Connected to MetaMask with address:", userAddress);
          console.log("LoanFactory:", factoryAddress);
          console.log("MockToken:", tokenContract.target);
          
          // Test contract connectivity
          try {
            await factoryContract.getLoansCount();
            console.log("‚úÖ Contract connectivity verified");
          } catch (contractError) {
            console.error("‚ùå Contract connectivity failed:", contractError);
            displayError("Contract not found! Make sure contracts are deployed to Sepolia testnet.");
            return;
          }
          
          // Load user balance
          await loadUserBalance();
          
          // Load initial data
          await Promise.all([
            loadLoans(),
            loadDashboardStats()
          ]);
          
          // Automatically check for pending penalties (no gas required)
          setTimeout(() => {
            checkPendingPenaltiesOnLoad();
          }, 2000); // Wait 2 seconds for loans to fully load
          
          displaySuccess(`Connected to Sepolia Testnet! Address: ${formatAddress(userAddress)}`);
          setTimeout(() => hideMessage('success'), 3000);
          
        } catch (error) {
          console.error("Init error:", error);
          displayError("Failed to connect: " + error.message);
        }
      } else {
        displayError("Please install MetaMask to use this DApp!");
        const networkStatus = document.getElementById("networkStatus");
        if (networkStatus) {
          networkStatus.innerHTML = `‚ùå MetaMask not installed`;
          networkStatus.style.background = 'rgba(244, 67, 54, 0.2)';
        }
      }
    }

    async function loadUserBalance() {
      try {
        if (userAddress && tokenContract) {
          const balance = await tokenContract.balanceOf(userAddress);
          userBalance = parseFloat(ethers.formatUnits(balance, 18));
          
          // Update balance display in dashboard
          const balanceElement = document.getElementById("userBalance");
          if (balanceElement) {
            balanceElement.textContent = `${userBalance.toFixed(2)} MTK`;
          }
          
          console.log("User MTK Balance:", userBalance);
        }
      } catch (error) {
        console.error("Error loading user balance:", error);
        userBalance = 0;
      }
    }

    // Cache for wallet balances to avoid repeated calls
    const balanceCache = new Map();

    async function loadWalletBalance(address, elementId, retryCount = 0) {
      try {
        console.log(`üîç Loading balance for ${address} -> ${elementId} (attempt ${retryCount + 1})`);
        
        // Check if element exists
        const element = document.getElementById(elementId);
        if (!element) {
          console.warn(`‚ö†Ô∏è Element ${elementId} not found, will retry...`);
          if (retryCount < 3) {
            setTimeout(() => loadWalletBalance(address, elementId, retryCount + 1), 500);
          }
          return;
        }

        // Check cache first
        if (balanceCache.has(address)) {
          const cachedBalance = balanceCache.get(address);
          console.log(`üí∞ Using cached balance for ${address}: ${cachedBalance}`);
          element.textContent = `${cachedBalance.toFixed(2)}`;
          element.style.color = cachedBalance > 0 ? '#059669' : '#dc2626';
          element.style.fontWeight = 'bold';
          return;
        }

        // Validate inputs
        if (!tokenContract) {
          console.error(`‚ùå Token contract not initialized for ${elementId}`);
          element.textContent = 'Contract Error';
          element.style.color = '#f44336';
          return;
        }

        if (!address || !ethers.isAddress(address)) {
          console.error(`‚ùå Invalid address for ${elementId}: ${address}`);
          element.textContent = 'Invalid Address';
          element.style.color = '#f44336';
          return;
        }

        // Show loading state
        element.textContent = 'Loading...';
        element.style.color = '#666';
        
        console.log(`üîó Fetching balance from blockchain for ${address}...`);
        const balance = await tokenContract.balanceOf(address);
        const balanceFormatted = parseFloat(ethers.formatUnits(balance, 18));
        
        console.log(`‚úÖ Balance loaded for ${address}: ${balanceFormatted} MTK`);
        
        // Cache the balance
        balanceCache.set(address, balanceFormatted);
        
        // Update the element
        element.textContent = `${balanceFormatted.toFixed(2)}`;
        element.style.color = balanceFormatted > 0 ? '#059669' : '#dc2626';
        element.style.fontWeight = 'bold';
        
      } catch (error) {
        console.error(`‚ùå Error loading balance for ${address} (${elementId}):`, error);
        const element = document.getElementById(elementId);
        if (element) {
          if (retryCount < 2) {
            console.log(`üîÑ Retrying balance load for ${address} in 1 second...`);
            element.textContent = `Retry ${retryCount + 1}/3...`;
            element.style.color = '#ff9800';
            setTimeout(() => loadWalletBalance(address, elementId, retryCount + 1), 1000);
          } else {
            element.textContent = 'Error';
            element.style.color = '#f44336';
          }
        }
      }
    }

    // Clear balance cache when switching accounts or networks
    function clearBalanceCache() {
      balanceCache.clear();
    }

    function displayError(message) {
      const errorDiv = document.getElementById("error");
      errorDiv.textContent = message;
      errorDiv.style.display = "block";
      setTimeout(() => hideMessage('error'), 5000);
    }

    function displaySuccess(message) {
      const successDiv = document.getElementById("success");
      successDiv.textContent = message;
      successDiv.style.display = "block";
    }

    function hideMessage(type) {
      document.getElementById(type).style.display = "none";
    }

    // Utility functions for time and formatting
    function formatTimestamp(timestamp) {
      return new Date(timestamp * 1000).toLocaleString();
    }

    function formatDuration(seconds) {
      const days = Math.floor(seconds / (24 * 60 * 60));
      const hours = Math.floor((seconds % (24 * 60 * 60)) / (60 * 60));
      if (days > 0) return `${days} days, ${hours}h`;
      return `${hours}h ${Math.floor((seconds % (60 * 60)) / 60)}m`;
    }

    function getTimeRemaining(targetTimestamp) {
      const now = Math.floor(Date.now() / 1000);
      const remaining = targetTimestamp - now;
      if (remaining <= 0) return { text: "Overdue", class: "overdue" };
      
      const days = Math.floor(remaining / (24 * 60 * 60));
      if (days > 0) return { text: `${days} days`, class: "upcoming" };
      
      const hours = Math.floor(remaining / (60 * 60));
      if (hours > 0) return { text: `${hours} hours`, class: "soon" };
      
      const minutes = Math.floor(remaining / 60);
      if (minutes > 0) return { text: `${minutes} minutes`, class: "urgent" };
      
      // Show seconds when under 1 minute
      return { text: `${remaining} seconds`, class: "critical" };
    }

    function formatAddress(address) {
      return `${address.slice(0, 6)}...${address.slice(-4)}`;
    }

    function copyToClipboard(text) {
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(text).then(() => {
          displaySuccess(`üìã Address copied to clipboard!\n${text}`);
          setTimeout(() => hideMessage('success'), 3000);
        }).catch(err => {
          console.error('Failed to copy text: ', err);
          fallbackCopyTextToClipboard(text);
        });
      } else {
        fallbackCopyTextToClipboard(text);
      }
    }

    // Fallback for browsers that don't support navigator.clipboard
    function fallbackCopyTextToClipboard(text) {
      const textArea = document.createElement("textarea");
      textArea.value = text;
      
      // Avoid scrolling to bottom
      textArea.style.top = "0";
      textArea.style.left = "0";
      textArea.style.position = "fixed";
      textArea.style.opacity = "0";

      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();

      try {
        const successful = document.execCommand('copy');
        if (successful) {
          displaySuccess(`üìã Address copied to clipboard!\n${text}`);
          setTimeout(() => hideMessage('success'), 3000);
        } else {
          displayError("Failed to copy address to clipboard");
        }
      } catch (err) {
        console.error('Fallback: Oops, unable to copy', err);
        displayError("Failed to copy address to clipboard");
      }

      document.body.removeChild(textArea);
    }

    function calculateLateFeeDisplay(loan) {
      const principal = parseFloat(loan.principal);
      const interestPercent = loan.interestPercent;
      const lateFeePercent = loan.lateFeePercent;
      const totalInstallments = loan.totalInstallments;
      const missedInstallments = loan.missedInstallments;
      
      // Calculate base amount (principal + interest)
      const baseAmount = principal + (principal * interestPercent / 100);
      
      // Calculate late fees
      const lateFeeAmount = (principal * lateFeePercent * missedInstallments) / (100 * totalInstallments);
      
      // Calculate expected total
      const expectedTotal = baseAmount + lateFeeAmount;
      
      // Check if actual total matches expected (accounting for rounding)
      const actualTotal = parseFloat(loan.totalOwed);
      const hasLateFees = lateFeeAmount > 0.01; // More than 1 cent in late fees
      
      // Calculate pending trust score penalties (FREE calculation)
      const pendingPenalties = calculatePendingTrustScorePenalties(loan);
      
      let display = '';
      
      if (hasLateFees) {
        display += `
          <br>
          <small style="color: #ff6b6b; font-weight: bold;">
            + ${lateFeeAmount.toFixed(2)} MTK late fees
          </small>
          <br>
          <small style="color: #666;">
            (${missedInstallments} missed √ó ${lateFeePercent}%)
          </small>
        `;
      }
      
      if (pendingPenalties > 0) {
        display += `
          <br>
          <small style="color: #e74c3c; font-weight: bold; background: rgba(231, 76, 60, 0.1); padding: 2px 6px; border-radius: 3px;">
            ‚ö†Ô∏è ${pendingPenalties} trust score penalties pending
          </small>
          <br>
          <small style="color: #e74c3c;">
            Will apply automatically on next payment
          </small>
        `;
      }
      
      return display;
    }

    // Calculate pending trust score penalties without requiring a transaction
    // This mirrors the exact logic from the smart contract
    function calculatePendingTrustScorePenalties(loan) {
      try {
        const now = Math.floor(Date.now() / 1000);
        const startTime = loan.startTimestamp;
        const interval = loan.installmentInterval;
        const totalInstallmentsNum = loan.totalInstallments;
        const repaidAmount = parseFloat(loan.repaid);
        const principal = parseFloat(loan.principal);
        const interestPercent = loan.interestPercent;
        
        // Mirror exact contract logic: countMissedInstallments
        const elapsedPeriods = Math.floor((now - startTime) / interval);
        const maxPeriods = Math.min(elapsedPeriods, totalInstallmentsNum);
        
        if (maxPeriods === 0) {
          return 0;
        }
        
        // Calculate total amount that should have been paid (with interest)
        const totalAmountWithInterest = principal * (1 + interestPercent / 100);
        const expectedAmountPaid = (totalAmountWithInterest * maxPeriods) / totalInstallmentsNum;
        
        // If we haven't received the expected amount, calculate missed installments
        if (expectedAmountPaid > repaidAmount) {
          const shortfall = expectedAmountPaid - repaidAmount; 
          const installmentAmount = totalAmountWithInterest / totalInstallmentsNum;
          
          // Calculate missed installments (rounded up) - matches contract logic
          const pendingPenalties = Math.ceil(shortfall / installmentAmount);
          return pendingPenalties;
        }
        
        return 0;
      } catch (error) {
        console.error("Error calculating pending penalties:", error);
        return 0;
      }
    }

    // Calculate the total amount needed to catch up on payments (including late fees)
    function calculateCatchUpAmount(loan) {
      try {
        const now = Math.floor(Date.now() / 1000);
        const startTime = loan.startTimestamp;
        const interval = loan.installmentInterval;
        const totalInstallmentsNum = loan.totalInstallments;
        const repaidAmount = parseFloat(loan.repaid);
        const principal = parseFloat(loan.principal);
        const interestPercent = loan.interestPercent;
        const lateFeePercent = loan.lateFeePercent;
        
        // Calculate elapsed periods
        const elapsedPeriods = Math.floor((now - startTime) / interval);
        const maxPeriods = Math.min(elapsedPeriods, totalInstallmentsNum);
        
        if (maxPeriods === 0) {
          // No payments due yet, return next installment amount
          const totalAmountWithInterest = principal * (1 + interestPercent / 100);
          return totalAmountWithInterest / totalInstallmentsNum;
        }
        
        // Calculate how much should have been paid by now (base amount)
        const totalAmountWithInterest = principal * (1 + interestPercent / 100);
        const expectedAmountPaid = (totalAmountWithInterest * maxPeriods) / totalInstallmentsNum;
        
        if (expectedAmountPaid <= repaidAmount) {
          // We're caught up! Return next installment amount if there are more payments
          if (maxPeriods < totalInstallmentsNum) {
            return totalAmountWithInterest / totalInstallmentsNum;
          } else {
            // Loan is fully paid
            return 0;
          }
        }
        
        // We're behind - calculate catch-up amount including late fees
        const shortfall = expectedAmountPaid - repaidAmount;
        const missedInstallments = Math.ceil(shortfall / (totalAmountWithInterest / totalInstallmentsNum));
        
        // Calculate late fees on missed installments
        const baseCatchUpAmount = shortfall;
        const lateFees = (baseCatchUpAmount * lateFeePercent) / 100;
        const totalCatchUpAmount = baseCatchUpAmount + lateFees;
        
        return totalCatchUpAmount;
        
      } catch (error) {
        console.error("Error calculating catch-up amount:", error);
        // Fallback to basic installment amount
        const totalAmountWithInterest = parseFloat(loan.principal) * (1 + loan.interestPercent / 100);
        return totalAmountWithInterest / loan.totalInstallments;
      }
    }

    async function createLoan() {
      const borrower = document.getElementById("borrower").value;
      const amount = document.getElementById("amount").value;
      const token = document.getElementById("token").value;
      const duration = document.getElementById("duration").value * 24 * 60 * 60;
      const interest = document.getElementById("interest").value;
      const lateFee = document.getElementById("lateFee").value;
      const installments = document.getElementById("installments").value;

      // Validation
      if (!borrower || !amount || !token || !duration || !interest || !lateFee || !installments) {
        displayError("Please fill in all fields");
        return;
      }

      if (!ethers.isAddress(borrower)) {
        displayError("Invalid borrower address");
        return;
      }

      if (!ethers.isAddress(token)) {
        displayError("Invalid token address");
        return;
      }

      try {
        hideMessage('error');
        hideMessage('success');
        
        const amountWei = ethers.parseUnits(amount, 18);
        
        // Check balance
        const balance = await tokenContract.balanceOf(userAddress);
        if (balance < amountWei) {
          displayError(`Insufficient balance. You have ${ethers.formatUnits(balance, 18)} MTK`);
          return;
        }
        
        displaySuccess("Approving tokens...");
        const approveTx = await tokenContract.approve(factoryAddress, amountWei);
        await approveTx.wait();
        
        displaySuccess("Creating loan...");
        const tx = await factoryContract.createLoan(
          borrower,
          amountWei,
          token,
          duration,
          interest,
          lateFee,
          installments
        );
        await tx.wait();
        
        displaySuccess("Loan created successfully! üéâ");
        
        // Clear form
        document.getElementById("borrower").value = "";
        document.getElementById("amount").value = "";
        document.getElementById("duration").value = "";
        document.getElementById("interest").value = "";
        document.getElementById("lateFee").value = "";
        document.getElementById("installments").value = "";
        
        // Reload data and refresh balances
        await Promise.all([loadLoans(), loadDashboardStats(), refreshAllBalances()]);
        
      } catch (error) {
        console.error("Create loan error:", error);
        displayError("Error creating loan: " + (error.reason || error.message));
      }
    }

    async function loadLoans() {
      // Prevent concurrent loading
      if (isLoadingLoans) {
        console.log("‚è≥ Loan loading already in progress, skipping...");
        return;
      }
      
      isLoadingLoans = true;
      
      try {
        console.log("üîÑ Starting fresh loan data load...");
        
        // Show loading for all sections
        document.getElementById("lenderLoansLoading").style.display = "block";
        document.getElementById("borrowerLoansLoading").style.display = "block";
        document.getElementById("otherLoansLoading").style.display = "block";
        
        // Hide grids
        document.getElementById("lenderLoansGrid").style.display = "none";
        document.getElementById("borrowerLoansGrid").style.display = "none";
        document.getElementById("otherLoansGrid").style.display = "none";
        
        // Clear arrays immediately to prevent duplicates
        allLoans = [];
        lenderLoans = [];
        borrowerLoans = [];
        otherLoans = [];
        
        // Force fresh data by recreating contracts
        const freshProvider = new ethers.BrowserProvider(window.ethereum);
        const freshSigner = await freshProvider.getSigner();
        const freshFactoryContract = new ethers.Contract(factoryAddress, LoanFactoryABI, freshSigner);
        
        const loans = await freshFactoryContract.getLoans();
        console.log(`üîÑ Loading ${loans.length} loans with fresh contracts...`);
        
        // Track processed loans to prevent duplicates
        const processedLoans = new Set();
        
        for (const loanAddress of loans) {
          // Skip if we've already processed this loan
          if (processedLoans.has(loanAddress)) {
            console.log(`‚ö†Ô∏è Skipping duplicate loan: ${loanAddress}`);
            continue;
          }
          processedLoans.add(loanAddress);
          try {
            const loanContract = new ethers.Contract(loanAddress, LoanAgreementABI, freshSigner);
            
            // Force fresh blockchain data by adding block tag
            const currentBlock = await freshProvider.getBlockNumber();
            console.log(`üîç Fetching loan data at block: ${currentBlock}`);
            
            // Get all loan data in parallel with explicit latest block
            const [
              status, borrower, lender, principal, repaid, totalOwed, 
              missedInstallments, startTimestamp, totalInstallments, 
              installmentInterval, interestPercent, lateFeePercent
            ] = await Promise.all([
              loanContract.getStatus({ blockTag: "latest" }),
              loanContract.borrower({ blockTag: "latest" }),
              loanContract.lender({ blockTag: "latest" }),
              loanContract.principal({ blockTag: "latest" }),
              loanContract.getRepaidAmount({ blockTag: "latest" }),
              loanContract.getTotalOwed({ blockTag: "latest" }),
              loanContract.countMissedInstallments({ blockTag: "latest" }),
              loanContract.startTimestamp({ blockTag: "latest" }),
              loanContract.totalInstallments({ blockTag: "latest" }),
              loanContract.installmentInterval({ blockTag: "latest" }),
              loanContract.interestPercent({ blockTag: "latest" }),
              loanContract.lateFeePercent({ blockTag: "latest" })
            ]);
            
            const loanData = {
              address: loanAddress,
              status: parseInt(status.toString()),
              borrower,
              lender,
              principal: ethers.formatUnits(principal, 18),
              repaid: ethers.formatUnits(repaid, 18),
              totalOwed: ethers.formatUnits(totalOwed, 18),
              missedInstallments: parseInt(missedInstallments.toString()),
              startTimestamp: parseInt(startTimestamp.toString()),
              totalInstallments: parseInt(totalInstallments.toString()),
              installmentInterval: parseInt(installmentInterval.toString()),
              interestPercent: parseInt(interestPercent.toString()),
              lateFeePercent: parseInt(lateFeePercent.toString())
            };
            
            // Debug logging for loan data (can be removed in production)
            console.log(`üìã Loan ${loanAddress}: ${loanData.totalOwed} MTK owed, ${loanData.missedInstallments} missed payments`);
            
            // Check if loan is already in allLoans to prevent duplicates
            const existingLoan = allLoans.find(loan => loan.address === loanAddress);
            if (existingLoan) {
              console.log(`‚ö†Ô∏è Loan ${loanAddress} already exists in allLoans, skipping...`);
              continue;
            }
            
            allLoans.push(loanData);
            
            // Categorize loans based on user's role
            if (userAddress) {
              console.log(`üîç CATEGORIZING LOAN ${loanAddress}:`);
              console.log(`  User Address: ${userAddress.toLowerCase()}`);
              console.log(`  Lender Address: ${lender.toLowerCase()}`);
              console.log(`  Borrower Address: ${borrower.toLowerCase()}`);
              console.log(`  Lender Match: ${lender.toLowerCase() === userAddress.toLowerCase()}`);
              console.log(`  Borrower Match: ${borrower.toLowerCase() === userAddress.toLowerCase()}`);
              
              if (lender.toLowerCase() === userAddress.toLowerCase()) {
                // Double-check not already in lenderLoans
                if (!lenderLoans.some(loan => loan.address === loanAddress)) {
                  console.log(`  ‚úÖ Added to LENDER loans`);
                  lenderLoans.push(loanData);
                } else {
                  console.log(`  ‚ö†Ô∏è Loan already in LENDER loans, skipping`);
                }
              } else if (borrower.toLowerCase() === userAddress.toLowerCase()) {
                // Double-check not already in borrowerLoans
                if (!borrowerLoans.some(loan => loan.address === loanAddress)) {
                  console.log(`  ‚úÖ Added to BORROWER loans`);
                  borrowerLoans.push(loanData);
                } else {
                  console.log(`  ‚ö†Ô∏è Loan already in BORROWER loans, skipping`);
                }
              } else {
                // Double-check not already in otherLoans
                if (!otherLoans.some(loan => loan.address === loanAddress)) {
                  console.log(`  ‚úÖ Added to OTHER loans`);
                  otherLoans.push(loanData);
                } else {
                  console.log(`  ‚ö†Ô∏è Loan already in OTHER loans, skipping`);
                }
              }
            }
            
          } catch (error) {
            console.error(`Error processing loan ${loanAddress}:`, error);
          }
        }
        
        // Hide loading
        document.getElementById("lenderLoansLoading").style.display = "none";
        document.getElementById("borrowerLoansLoading").style.display = "none";
        document.getElementById("otherLoansLoading").style.display = "none";
        
        // Display loans in each section with debugging
        console.log(`üìä FINAL CATEGORIZATION SUMMARY:`);
        console.log(`  üë§ User Address: ${userAddress}`);
        console.log(`  üè¶ Lender Loans: ${lenderLoans.length} loans`);
        console.log(`  üë§ Borrower Loans: ${borrowerLoans.length} loans`);
        console.log(`  üåê Other Loans: ${otherLoans.length} loans`);
        
        displayLenderLoans();
        displayBorrowerLoans();
        displayOtherLoans();
        
        console.log("‚úÖ Loan loading completed successfully");
        
      } catch (error) {
        console.error("Load loans error:", error);
        displayError("Error loading loans: " + error.message);
        document.getElementById("lenderLoansLoading").style.display = "none";
        document.getElementById("borrowerLoansLoading").style.display = "none";
        document.getElementById("otherLoansLoading").style.display = "none";
      } finally {
        // Always reset the loading flag
        isLoadingLoans = false;
      }
    }

    function displayLenderLoans() {
      const loansGrid = document.getElementById("lenderLoansGrid");
      const noLoansDiv = document.getElementById("noLenderLoans");  
      const filteredLoans = filterLoansByStatus(lenderLoans, currentLenderFilter);
      
      // Remove any duplicates by address (final safeguard)
      const uniqueLoans = filteredLoans.filter((loan, index, self) => 
        index === self.findIndex(l => l.address === loan.address)
      );
      
      if (uniqueLoans.length !== filteredLoans.length) {
        console.log(`‚ö†Ô∏è Removed ${filteredLoans.length - uniqueLoans.length} duplicate lender loans`);
      }
      
      console.log(`üè¶ DISPLAYING LENDER LOANS:`);
      console.log(`  Raw lender loans: ${lenderLoans.length}`);
      console.log(`  Filtered lender loans: ${filteredLoans.length}`);
      console.log(`  Unique lender loans: ${uniqueLoans.length}`);
      uniqueLoans.forEach(loan => {
        console.log(`    Loan ${loan.address}: Lender=${loan.lender}, Borrower=${loan.borrower}`);
      });
      
      if (uniqueLoans.length === 0) {
        loansGrid.style.display = "none";
        noLoansDiv.style.display = "block";
        return;
      }
      
      noLoansDiv.style.display = "none";
      loansGrid.style.display = "grid";
      loansGrid.innerHTML = uniqueLoans.map(loan => createLoanCard(loan)).join('');
      
      // Trigger balance loading after DOM is updated for lender loans
      setTimeout(() => {
        uniqueLoans.forEach(loan => {
          const borrowerBalanceId = `balance-${loan.borrower}`;
          const lenderBalanceId = `balance-${loan.lender}`;
          loadWalletBalance(loan.borrower, borrowerBalanceId);
          loadWalletBalance(loan.lender, lenderBalanceId);
        });
      }, 200);
    }

    function displayBorrowerLoans() {
      const loansGrid = document.getElementById("borrowerLoansGrid");
      const noLoansDiv = document.getElementById("noBorrowerLoans");
      const filteredLoans = filterLoansByStatus(borrowerLoans, currentBorrowerFilter);
      
      // Remove any duplicates by address (final safeguard)
      const uniqueLoans = filteredLoans.filter((loan, index, self) => 
        index === self.findIndex(l => l.address === loan.address)
      );
      
      if (uniqueLoans.length !== filteredLoans.length) {
        console.log(`‚ö†Ô∏è Removed ${filteredLoans.length - uniqueLoans.length} duplicate borrower loans`);
      }
      
      console.log(`üë§ DISPLAYING BORROWER LOANS:`);
      console.log(`  Raw borrower loans: ${borrowerLoans.length}`);
      console.log(`  Filtered borrower loans: ${filteredLoans.length}`);
      console.log(`  Unique borrower loans: ${uniqueLoans.length}`);
      uniqueLoans.forEach(loan => {
        console.log(`    Loan ${loan.address}: Lender=${loan.lender}, Borrower=${loan.borrower}`);
      });
      
      if (uniqueLoans.length === 0) {
        loansGrid.style.display = "none";
        noLoansDiv.style.display = "block";
        return;
      }
      
      noLoansDiv.style.display = "none";
      loansGrid.style.display = "grid";
      loansGrid.innerHTML = uniqueLoans.map(loan => createLoanCard(loan)).join('');
      
      // Trigger balance loading after DOM is updated for borrower loans
      setTimeout(() => {
        uniqueLoans.forEach(loan => {
          const borrowerBalanceId = `balance-${loan.borrower}`;
          const lenderBalanceId = `balance-${loan.lender}`;
          loadWalletBalance(loan.borrower, borrowerBalanceId);
          loadWalletBalance(loan.lender, lenderBalanceId);
        });
      }, 200);
    }

    function displayOtherLoans() {
      const loansGrid = document.getElementById("otherLoansGrid");
      const noLoansDiv = document.getElementById("noOtherLoans");
      const filteredLoans = filterLoansByStatus(otherLoans, currentOtherFilter);
      
      // Remove any duplicates by address (final safeguard)
      const uniqueLoans = filteredLoans.filter((loan, index, self) => 
        index === self.findIndex(l => l.address === loan.address)
      );
      
      if (uniqueLoans.length !== filteredLoans.length) {
        console.log(`‚ö†Ô∏è Removed ${filteredLoans.length - uniqueLoans.length} duplicate other loans`);
      }
      
      console.log(`üåê DISPLAYING OTHER LOANS:`);
      console.log(`  Raw other loans: ${otherLoans.length}`);
      console.log(`  Filtered other loans: ${filteredLoans.length}`);
      console.log(`  Unique other loans: ${uniqueLoans.length}`);
      
      if (uniqueLoans.length === 0) {
        loansGrid.style.display = "none";
        noLoansDiv.style.display = "block";
        return;
      }
      
      noLoansDiv.style.display = "none";
      loansGrid.style.display = "grid";
      loansGrid.innerHTML = uniqueLoans.map(loan => createLoanCard(loan)).join('');
      
      // Trigger balance loading after DOM is updated for other loans
      setTimeout(() => {
        uniqueLoans.forEach(loan => {
          const borrowerBalanceId = `balance-${loan.borrower}`;
          const lenderBalanceId = `balance-${loan.lender}`;
          loadWalletBalance(loan.borrower, borrowerBalanceId);
          loadWalletBalance(loan.lender, lenderBalanceId);
        });
      }, 200);
    }

    function createLoanCard(loan) {
      const statusText = ["Active", "Repaid", "Defaulted"][loan.status];
      const statusClass = ["active", "repaid", "defaulted"][loan.status];
      const repaymentProgress = (parseFloat(loan.repaid) / parseFloat(loan.totalOwed)) * 100;
      
      const now = Math.floor(Date.now() / 1000);
      const nextInstallmentTime = loan.startTimestamp + (Math.floor((now - loan.startTimestamp) / loan.installmentInterval) + 1) * loan.installmentInterval;
      const timeRemaining = getTimeRemaining(nextInstallmentTime);
      
      const installmentAmount = parseFloat(loan.totalOwed) / loan.totalInstallments;

      // Add balance info for borrower and lender
      const borrowerBalanceId = `balance-${loan.borrower}`;
      const lenderBalanceId = `balance-${loan.lender}`;
      
      // Balance loading is handled by display functions after DOM is updated
      
      return `
        <div class="loan-card">
          <div class="loan-header ${statusClass}">
            ${statusText} Loan
            <small style="float: right; opacity: 0.8;">
              <span class="address-clickable" onclick="copyToClipboard('${loan.address}')" title="Click to copy loan contract address" style="background: rgba(255,255,255,0.2); color: inherit; border: 1px solid rgba(255,255,255,0.3);">
                ${formatAddress(loan.address)}
                <span class="copy-icon">üìã</span>
              </span>
            </small>
          </div>
          <div class="loan-body">
            <div class="loan-details">
              <div class="detail-item">
                <span class="detail-label">üë§ Borrower:</span>
                <div style="text-align: right;">
                  <span class="address-clickable" onclick="copyToClipboard('${loan.borrower}')" title="Click to copy full address">
                    ${formatAddress(loan.borrower)}
                    <span class="copy-icon">üìã</span>
                  </span>
                  <br>
                  <small style="color: #666; margin-top: 4px; display: block;">Balance: <span id="${borrowerBalanceId}">Loading...</span> MTK</small>
                </div>
              </div>
              <div class="detail-item">
                <span class="detail-label">üè¶ Lender:</span>
                <div style="text-align: right;">
                  <span class="address-clickable" onclick="copyToClipboard('${loan.lender}')" title="Click to copy full address">
                    ${formatAddress(loan.lender)}
                    <span class="copy-icon">üìã</span>
                  </span>
                  <br>
                  <small style="color: #666; margin-top: 4px; display: block;">Balance: <span id="${lenderBalanceId}">Loading...</span> MTK</small>
                </div>
              </div>
              <div class="detail-item">
                <span class="detail-label">üí∞ Principal:</span>
                <span class="detail-value">${parseFloat(loan.principal).toFixed(2)} MTK</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">üí∏ Repaid:</span>
                <span class="detail-value">${parseFloat(loan.repaid).toFixed(2)} MTK</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">üìä Total Owed:</span>
                <div style="text-align: right;">
                  <span class="detail-value">${loan.missedInstallments > 0 ? parseFloat(loan.totalOwed).toFixed(6) : parseFloat(loan.totalOwed).toFixed(2)} MTK</span>
                  ${calculateLateFeeDisplay(loan)}
                </div>
              </div>
              <div class="detail-item">
                <span class="detail-label">üìà Interest:</span>
                <span class="detail-value">${loan.interestPercent}%</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">‚ö†Ô∏è Late Fee:</span>
                <span class="detail-value">${loan.lateFeePercent}%</span>
              </div>
            </div>
            
            <div class="progress-bar">
              <div class="progress-fill" style="width: ${Math.min(repaymentProgress, 100)}%">
                ${repaymentProgress.toFixed(1)}% Repaid
              </div>
            </div>
            
            <div class="time-info">
              <div class="time-grid">
                <div>
                  <strong>üìÖ Started:</strong><br>
                  ${formatTimestamp(loan.startTimestamp)}
                </div>
                <div>
                  <strong>‚è∞ Next Due:</strong><br>
                  <span class="${timeRemaining.class}" data-target-timestamp="${nextInstallmentTime}">${timeRemaining.text}</span>
                </div>
              </div>
            </div>
            
            <div class="installment-schedule">
              <div class="installment-schedule-header">
                üìã Installment Schedule (${loan.totalInstallments} payments)
                ${loan.totalInstallments > 6 ? '<small style="color: #666; font-weight: normal;">‚ÜïÔ∏è Scroll to see all</small>' : ''}
              </div>
              <div class="installment-container">
                ${createInstallmentSchedule(loan)}
              </div>
            </div>
            
            ${loan.missedInstallments > 0 ? `
              <div style="color: #ff6b6b; font-weight: bold; margin-top: 10px;">
                ‚ö†Ô∏è ${loan.missedInstallments} missed installment(s)
              </div>
            ` : ''}
            
            ${loan.status === 0 ? `
              <div style="margin-top: 15px; display: flex; gap: 10px;">
                ${loan.borrower.toLowerCase() === userAddress?.toLowerCase() ? `
                  ${(() => {
                    const catchUpAmount = calculateCatchUpAmount(loan);
                    const pendingPenalties = calculatePendingTrustScorePenalties(loan);
                    const buttonText = pendingPenalties > 0 
                      ? `üí∏ Catch Up (${catchUpAmount.toFixed(2)} MTK)` 
                      : `üí∏ Pay Installment (${catchUpAmount.toFixed(2)} MTK)`;
                    const buttonStyle = pendingPenalties > 0 
                      ? 'background: #dc2626; color: white;' 
                      : '';
                    
                    if (catchUpAmount <= 0) {
                      return '<span style="color: #059669; font-weight: bold;">‚úÖ Loan Fully Paid</span>';
                    }
                    
                    return '<button class="btn" style="' + buttonStyle + '" onclick="quickRepay(\'' + loan.address + '\', ' + catchUpAmount.toFixed(6) + ')">' + buttonText + '</button>';
                  })()}
                ` : ''}
                ${loan.lender.toLowerCase() === userAddress?.toLowerCase() ? `
                  <button class="btn btn-danger" onclick="quickDefault('${loan.address}')">
                    ‚ö†Ô∏è Mark Default
                  </button>
                ` : ''}
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    function createInstallmentSchedule(loan) {
      const installments = [];
      const installmentAmount = parseFloat(loan.totalOwed) / loan.totalInstallments;
      const paidInstallments = Math.floor((parseFloat(loan.repaid) / parseFloat(loan.totalOwed)) * loan.totalInstallments);
      
      let paidCount = 0;
      let overdueCount = 0;
      let upcomingCount = 0;
      
      for (let i = 0; i < loan.totalInstallments; i++) {
        const dueTime = loan.startTimestamp + (i + 1) * loan.installmentInterval;
        const now = Math.floor(Date.now() / 1000);
        
        let status, className, icon;
        if (i < paidInstallments) {
          status = "Paid";
          className = "installment-paid";
          icon = "‚úÖ";
          paidCount++;
        } else if (dueTime < now) {
          status = "Overdue";
          className = "installment-due";
          icon = "‚ùå";
          overdueCount++;
        } else {
          status = "Upcoming";
          className = "installment-upcoming";
          icon = "‚è≥";
          upcomingCount++;
        }
        
        installments.push(`
          <div class="installment-item">
            <div style="flex: 1;">
              <strong>#${i + 1}</strong> - ${formatTimestamp(dueTime)}
            </div>
            <div style="text-align: right;">
              <div class="${className}" style="font-weight: bold;">${icon} ${status}</div>
              <small style="color: #666;">${installmentAmount.toFixed(2)} MTK</small>
            </div>
          </div>
        `);
      }
      
      // Add summary at the top if there are many installments
      let summary = '';
      if (loan.totalInstallments > 5) {
        summary = `
          <div style="background: #fff; padding: 10px; border-radius: 6px; margin-bottom: 15px; border: 1px solid #e9ecef;">
            <div style="display: flex; justify-content: space-between; font-size: 0.9rem;">
              <span style="color: #059669;">‚úÖ ${paidCount} Paid</span>
              <span style="color: #dc2626;">‚ùå ${overdueCount} Overdue</span>
              <span style="color: #64748b;">‚è≥ ${upcomingCount} Upcoming</span>
            </div>
          </div>
        `;
      }
      
      return summary + installments.join('');
    }

    async function repayLoan() {
        const loanAddress = document.getElementById("repayLoanAddress").value;
        const amount = document.getElementById("repayAmount").value;

      if (!loanAddress || !amount) {
        displayError("Please enter loan address and repayment amount");
        return;
      }

      if (!ethers.isAddress(loanAddress)) {
        displayError("Invalid loan address");
        return;
      }

      try {
        hideMessage('error');
        hideMessage('success');
        
            const loanContract = new ethers.Contract(loanAddress, LoanAgreementABI, signer);
            const borrower = await loanContract.borrower();
        
            if (borrower.toLowerCase() !== userAddress.toLowerCase()) {
          displayError(`Only the borrower can repay this loan. Borrower: ${formatAddress(borrower)}`);
            return;
            }
        
            const amountWei = ethers.parseUnits(amount, 18);
        const balance = await tokenContract.balanceOf(userAddress);
        
        if (balance < amountWei) {
          displayError(`Insufficient balance. You have ${ethers.formatUnits(balance, 18)} MTK`);
          return;
        }
        
        displaySuccess("Approving tokens for repayment...");
            const approveTx = await tokenContract.approve(loanAddress, amountWei);
            await approveTx.wait();
        
        displaySuccess("Processing repayment...");
            const repayTx = await loanContract.repay(amountWei);
            await repayTx.wait();
        
        displaySuccess("Repayment successful! üí∞");
        
        // Clear form
        document.getElementById("repayLoanAddress").value = "";
        document.getElementById("repayAmount").value = "";
        
                // Reload data and refresh balances
        await Promise.all([loadLoans(), loadDashboardStats(), refreshAllBalances()]);
        
        } catch (error) {
            console.error("Repay error:", error);
        displayError("Error repaying loan: " + (error.reason || error.message));
      }
    }

    async function quickRepay(loanAddress, amount) {
      document.getElementById("repayLoanAddress").value = loanAddress;
      document.getElementById("repayAmount").value = amount;
      await repayLoan();
    }

    async function markDefault() {
      const loanAddress = document.getElementById("defaultLoanAddress").value;

      if (!loanAddress) {
        displayError("Please enter loan address");
        return;
      }

      if (!ethers.isAddress(loanAddress)) {
        displayError("Invalid loan address");
        return;
      }

      if (!confirm("Are you sure you want to mark this loan as default? This action cannot be undone.")) {
        return;
      }

      try {
        hideMessage('error');
        hideMessage('success');
        
        const loanContract = new ethers.Contract(loanAddress, LoanAgreementABI, signer);
        const lender = await loanContract.lender();
        
        if (lender.toLowerCase() !== userAddress.toLowerCase()) {
          displayError(`Only the lender can mark this loan as default. Lender: ${formatAddress(lender)}`);
          return;
        }
        
        displaySuccess("Marking loan as default...");
        const tx = await loanContract.markDefault();
        await tx.wait();
        
        displaySuccess("Loan marked as default! ‚ö†Ô∏è");
        
        // Clear form
        document.getElementById("defaultLoanAddress").value = "";
        
        // Reload data and refresh balances
        await Promise.all([loadLoans(), loadDashboardStats(), refreshAllBalances()]);
        
      } catch (error) {
        console.error("Mark default error:", error);
        displayError("Error marking default: " + (error.reason || error.message));
      }
    }

    async function quickDefault(loanAddress) {
      document.getElementById("defaultLoanAddress").value = loanAddress;
      await markDefault();
    }

    async function getTrustScore() {
      const user = document.getElementById("trustAddress").value;
      
      if (!user) {
        displayError("Please enter user address");
        return;
      }

      if (!ethers.isAddress(user)) {
        displayError("Invalid user address");
        return;
      }

      try {
        hideMessage('error');
        const score = await factoryContract.getTrustScore(user);
        document.getElementById("trustScore").innerHTML = `
          <strong>Trust Score:</strong> 
          <span style="color: ${score >= 0 ? '#059669' : '#dc2626'};">
            ${score.toString()} ${score >= 0 ? '‚≠ê' : '‚ö†Ô∏è'}
          </span>
        `;
      } catch (error) {
        console.error("Trust score error:", error);
        displayError("Error getting trust score: " + error.message);
      }
    }

    // Filtering functions
    function filterLenderLoans(filterType) {
      currentLenderFilter = filterType;
      
      // Update active filter button for lender section
      const lenderSection = event.target.closest('.section');
      lenderSection.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      displayLenderLoans();
    }

    function filterBorrowerLoans(filterType) {
      currentBorrowerFilter = filterType;
      
      // Update active filter button for borrower section
      const borrowerSection = event.target.closest('.section');
      borrowerSection.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      displayBorrowerLoans();
    }

    function filterOtherLoans(filterType) {
      currentOtherFilter = filterType;
      
      // Update active filter button for other section
      const otherSection = event.target.closest('.section');
      otherSection.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
      event.target.classList.add('active');
      
      displayOtherLoans();
    }

    function filterLoansByStatus(loans, filterType) {
      let filtered = [...loans];
      
      switch (filterType) {
        case 'active':
          filtered = filtered.filter(loan => loan.status === 0);
          break;
        case 'repaid':
          filtered = filtered.filter(loan => loan.status === 1);
          break;
        case 'defaulted':
          filtered = filtered.filter(loan => loan.status === 2);
          break;
        // 'all' shows everything
      }
      
      return filtered;
    }

    // Dashboard statistics
    async function loadDashboardStats() {
      try {
        const totalLoans = lenderLoans.length + borrowerLoans.length;
        const activeLoans = [...lenderLoans, ...borrowerLoans].filter(loan => loan.status === 0).length;
        
        document.getElementById("totalLoans").textContent = totalLoans;
        document.getElementById("activeLoans").textContent = activeLoans;
        
        // Get user's trust score
        if (userAddress) {
          try {
            const score = await factoryContract.getTrustScore(userAddress);
            document.getElementById("userTrustScore").innerHTML = `
              <span style="color: ${score >= 0 ? '#059669' : '#dc2626'};">
                ${score.toString()} ${score >= 0 ? '‚≠ê' : '‚ö†Ô∏è'}
              </span>
            `;
          } catch (error) {
            document.getElementById("userTrustScore").textContent = "0";
          }
        }
        
      } catch (error) {
        console.error("Error loading dashboard stats:", error);
      }
    }

    // Listen for account and network changes
    if (typeof window.ethereum !== 'undefined') {
      window.ethereum.on('accountsChanged', (accounts) => {
        console.log('Account changed:', accounts[0]);
        clearBalanceCache();
        location.reload(); // Reload to reinitialize with new account
      });

      window.ethereum.on('chainChanged', (chainId) => {
        console.log('Network changed:', chainId);
        clearBalanceCache();
        location.reload(); // Reload to check network compatibility
      });
    }

    // Auto-refresh data every 30 seconds
    setInterval(async () => {
      if (provider && signer) {
        try {
          await Promise.all([
            loadLoans(), 
            loadDashboardStats(),
            loadUserBalance()
          ]);
        } catch (error) {
          console.error("Auto-refresh error:", error);
        }
      }
    }, 30000);

    // Update time displays more frequently (every 10 seconds)
    setInterval(() => {
      updateTimeDisplays();
    }, 10000);

    // Update critical times every second (for seconds countdown)
    setInterval(() => {
      updateCriticalTimes();
    }, 1000);

    // Function to update only time-sensitive displays without full reload
    function updateTimeDisplays() {
      try {
        const timeElements = document.querySelectorAll('[data-target-timestamp]');
        timeElements.forEach(element => {
          const targetTimestamp = parseInt(element.getAttribute('data-target-timestamp'));
          const timeRemaining = getTimeRemaining(targetTimestamp);
          element.textContent = timeRemaining.text;
          element.className = timeRemaining.class;
        });
      } catch (error) {
        console.error("Error updating time displays:", error);
      }
    }

    // Function to update only critical time elements (under 1 minute) every second
    function updateCriticalTimes() {
      try {
        const timeElements = document.querySelectorAll('[data-target-timestamp]');
        let shouldRefreshOverdueLoans = false;
        
        timeElements.forEach(element => {
          const targetTimestamp = parseInt(element.getAttribute('data-target-timestamp'));
          const now = Math.floor(Date.now() / 1000);
          const remaining = targetTimestamp - now;
          
          // Check if any payment just became overdue (within last 10 seconds)
          if (remaining <= 0 && remaining >= -10) {
            shouldRefreshOverdueLoans = true;
          }
          
          // Only update if remaining time is less than 5 minutes (for better performance)
          if (remaining <= 300 && remaining > 0) {
            const timeRemaining = getTimeRemaining(targetTimestamp);
            element.textContent = timeRemaining.text;
            element.className = timeRemaining.class;
          }
        });

        // Refresh loan data when payments become overdue to update total owed amounts
        if (shouldRefreshOverdueLoans) {
          console.log("Payment became overdue - refreshing loan data to update totals");
          forceRefreshLoanDataWithPenalties(); // This will apply late fees and recalculate totals
        }
      } catch (error) {
        console.error("Error updating critical times:", error);
      }
    }

    // Refresh balances when loans are updated
    async function refreshAllBalances() {
      console.log("üîÑ Refreshing all balances...");
      clearBalanceCache();
      await loadUserBalance();
      
      // Force reload all visible balance elements
      const balanceElements = document.querySelectorAll('[id^="balance-"]');
      console.log(`üîç Found ${balanceElements.length} balance elements to refresh`);
      
      balanceElements.forEach(element => {
        const elementId = element.id;
        const address = elementId.replace('balance-', '');
        if (address && ethers.isAddress(address)) {
          console.log(`üîÑ Refreshing balance for ${address}`);
          element.textContent = 'Loading...';
          element.style.color = '#666';
          setTimeout(() => loadWalletBalance(address, elementId), 200);
        }
      });
    }

    // Manual balance refresh with user feedback
    async function manualRefreshBalances() {
      try {
        displaySuccess("üîÑ Refreshing all wallet balances...");
        await refreshAllBalances();
        
        // Wait a bit for balance loading to complete
        setTimeout(() => {
          displaySuccess("üí∞ All wallet balances refreshed!");
          setTimeout(() => hideMessage('success'), 3000);
        }, 2000);
      } catch (error) {
        console.error("Error refreshing balances:", error);
        displayError("Error refreshing balances: " + error.message);
      }
    }

    // Manual refresh function for loan data
    async function refreshLoanData() {
      try {
        console.log("üîÑ refreshLoanData() called");
        displaySuccess("Refreshing loan data...");
        
        // Clear balance cache to force fresh balance data
        clearBalanceCache();
        
        // loadLoans() will handle clearing arrays and prevent concurrent calls
        await loadLoans();
        await Promise.all([
          loadDashboardStats(),
          refreshAllBalances()
        ]);
        displaySuccess("Loan data refreshed! ‚úÖ Late fees and totals updated.");
        setTimeout(() => hideMessage('success'), 3000);
      } catch (error) {
        console.error("‚ùå Error refreshing loan data:", error);
        displayError("Error refreshing loan data: " + error.message);
      }
    }

    // Force refresh with penalty application (automatically applies late fees)
    async function forceRefreshLoanDataWithPenalties() {
      try {
        console.log("üîÑ forceRefreshLoanDataWithPenalties() called - applying late fees");
        
        if (!factoryContract) {
          console.error("Factory contract not initialized");
          return;
        }

        // Get all loans and apply penalties to each active loan
        const loanAddresses = await factoryContract.getLoans();
        console.log(`üìã Found ${loanAddresses.length} loans to check for late fees`);
        
        // Apply penalties to all loans (this updates accumulatedLateFees)
        for (const loanAddress of loanAddresses) {
          try {
            const loanContract = new ethers.Contract(loanAddress, LoanAgreementABI, signer);
            
            // Check if loan is still active
            const status = await loanContract.getStatus();
            if (status === 0) { // Active loan
              console.log(`‚ö†Ô∏è Applying late fees to loan ${loanAddress}`);
              
              // Call checkAndPenalizeLatePayments to accumulate any pending late fees
              // This is a state-changing call but doesn't require being the borrower
              await loanContract.checkAndPenalizeLatePayments();
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è Could not apply penalties to loan ${loanAddress}:`, error.message);
            // Continue with other loans - some might fail if they don't need penalties
          }
        }
        
        // Now refresh the loan data to get updated totals
        console.log("üîÑ Refreshing loan data after applying penalties");
        await loadLoans();
        
      } catch (error) {
        console.error("‚ùå Error in forceRefreshLoanDataWithPenalties:", error);
      }
    }

    // Show pending late payment penalties (FREE - no transaction required)
    async function showPendingPenalties() {
      try {
        console.log("üîç showPendingPenalties() called");
        displaySuccess("Analyzing pending late payment penalties...");
        
        if (!factoryContract) {
          console.error("‚ùå Factory contract not initialized");
          displayError("Factory contract not initialized");
          return;
        }

        const loanAddresses = await factoryContract.getLoans();
        let totalPendingPenalties = 0;
        let affectedLoans = 0;
        let penaltyDetails = [];

        for (const loanAddress of loanAddresses) {
          try {
            const loanContract = new ethers.Contract(loanAddress, LoanAgreementABI, signer);
            
            // Get loan basic info
            const [borrower, startTimestamp, installmentInterval, totalInstallments, repaidAmount, principal, interestPercent] = await Promise.all([
              loanContract.borrower(),
              loanContract.startTimestamp(),
              loanContract.installmentInterval(),
              loanContract.totalInstallments(),
              loanContract.getRepaidAmount(),
              loanContract.principal(),
              loanContract.interestPercent()
            ]);

            // Calculate pending penalties using EXACT contract logic
            const now = Math.floor(Date.now() / 1000);
            const startTime = parseInt(startTimestamp.toString());
            const interval = parseInt(installmentInterval.toString());
            const totalInstallmentsNum = parseInt(totalInstallments.toString());
            const repaidEther = parseFloat(ethers.formatUnits(repaidAmount, 18));
            const principalEther = parseFloat(ethers.formatUnits(principal, 18));
            const interestPercentNum = parseInt(interestPercent.toString());

            const elapsedPeriods = Math.floor((now - startTime) / interval);
            const maxPeriods = Math.min(elapsedPeriods, totalInstallmentsNum);
            
            let pendingPenaltiesForLoan = 0;
            const lateInstallments = [];

            if (maxPeriods > 0) {
              // Use exact contract logic for consistency
              const totalAmountWithInterest = principalEther * (1 + interestPercentNum / 100);
              const expectedAmountPaid = (totalAmountWithInterest * maxPeriods) / totalInstallmentsNum;
              
              if (expectedAmountPaid > repaidEther) {
                const shortfall = expectedAmountPaid - repaidEther;
                const installmentAmount = totalAmountWithInterest / totalInstallmentsNum;
                
                // Calculate missed installments (rounded up) - matches contract
                pendingPenaltiesForLoan = Math.ceil(shortfall / installmentAmount);
                
                // Build detailed breakdown for display
                for (let i = 1; i <= maxPeriods; i++) {
                  const dueTime = startTime + (i * interval);
                  const expectedByThisPeriod = (totalAmountWithInterest * i) / totalInstallmentsNum;
                  
                  if (now > dueTime && repaidEther < expectedByThisPeriod) {
                    lateInstallments.push({
                      installmentNumber: i,
                      dueTime: dueTime,
                      minutesLate: Math.floor((now - dueTime) / 60)
                    });
                  }
                }
              }
            }

            if (pendingPenaltiesForLoan > 0) {
              affectedLoans++;
              totalPendingPenalties += pendingPenaltiesForLoan;
              penaltyDetails.push({
                address: loanAddress,
                borrower: borrower,
                principal: principalEther,
                pendingPenalties: pendingPenaltiesForLoan,
                lateInstallments: lateInstallments
              });
            }
            
          } catch (error) {
            console.log(`‚ùå Error analyzing loan ${loanAddress}:`, error.message);
          }
        }

        // Display results
        if (totalPendingPenalties === 0) {
          displaySuccess(`‚úÖ No pending late payment penalties found across ${loanAddresses.length} loans.`);
        } else {
          let message = `‚ö†Ô∏è Found ${totalPendingPenalties} pending late payment penalties across ${affectedLoans} loans:\n\n`;
          
          penaltyDetails.forEach(loan => {
            message += `üìã Loan ${loan.address.slice(0, 8)}...:\n`;
            message += `   üë§ Borrower: ${loan.borrower.slice(0, 8)}...\n`;
            message += `   üí∞ Principal: ${loan.principal} MTK\n`;
            message += `   ‚ö†Ô∏è Pending Penalties: -${loan.pendingPenalties} trust score\n`;
            message += `   üìÖ Late Installments: ${loan.lateInstallments.map(i => `#${i.installmentNumber} (${i.minutesLate}min late)`).join(', ')}\n\n`;
          });
          
          message += `üí° These penalties will be automatically applied when borrowers make their next payment.\n`;
          message += `üéØ Total trust score impact: -${totalPendingPenalties} points`;
          
          displayError(message);
          
          // Show individual loan warnings
          penaltyDetails.forEach(loan => {
            console.log(`üö® Loan ${loan.address}: ${loan.pendingPenalties} pending penalties for borrower ${loan.borrower}`);
          });
        }
        
      } catch (error) {
        console.error("Error analyzing pending penalties:", error);
        displayError("Error analyzing pending penalties: " + error.message);
      }
    }

    // Show trust scores for all participants (FREE - no transaction required)
    async function showTrustScores() {
      try {
        console.log("üìä showTrustScores() called");
        displaySuccess("Loading trust scores for all participants...");
        
        if (!factoryContract) {
          console.error("‚ùå Factory contract not initialized");
          displayError("Factory contract not initialized");
          return;
        }

        const loanAddresses = await factoryContract.getLoans();
        const participantAddresses = new Set();
        
        // Collect all unique participant addresses
        for (const loanAddress of loanAddresses) {
          try {
            const loanContract = new ethers.Contract(loanAddress, LoanAgreementABI, signer);
            const [borrower, lender] = await Promise.all([
              loanContract.borrower(),
              loanContract.lender()
            ]);
            participantAddresses.add(borrower);
            participantAddresses.add(lender);
          } catch (error) {
            // Skip individual loan errors
          }
        }

        // Get trust scores for all participants
        const trustScorePromises = Array.from(participantAddresses).map(async (address) => {
          try {
            const trustScore = await factoryContract.getTrustScore(address);
            return {
              address: address,
              trustScore: parseInt(trustScore.toString()),
              isCurrentUser: address.toLowerCase() === userAddress.toLowerCase()
            };
          } catch (error) {
            return {
              address: address,
              trustScore: 0,
              isCurrentUser: address.toLowerCase() === userAddress.toLowerCase(),
              error: true
            };
          }
        });

        const trustScores = await Promise.all(trustScorePromises);
        
        // Sort by trust score (highest first)
        trustScores.sort((a, b) => b.trustScore - a.trustScore);

        // Format results
        let message = `üìä Trust Scores for ${trustScores.length} Participants:\n\n`;
        
        trustScores.forEach((participant, index) => {
          const rank = index + 1;
          const badge = participant.isCurrentUser ? " üë§ (You)" : "";
          const scoreColor = participant.trustScore >= 0 ? "‚úÖ" : "‚ùå";
          const errorNote = participant.error ? " (Error loading)" : "";
          
          message += `${rank}. ${participant.address.slice(0, 8)}...${badge}\n`;
          message += `   ${scoreColor} Trust Score: ${participant.trustScore}${errorNote}\n\n`;
        });

        message += `üí° Trust Score Guide:\n`;
        message += `‚Ä¢ Positive scores: Reliable payment history\n`;
        message += `‚Ä¢ Zero: New user or mixed performance\n`;
        message += `‚Ä¢ Negative scores: History of late/missed payments\n`;
        message += `‚Ä¢ Each late payment: -1 point\n`;
        message += `‚Ä¢ Each perfect loan completion: +1 point\n`;
        message += `‚Ä¢ Loan default: -2 points`;

        displaySuccess(message);
        
      } catch (error) {
        console.error("Error loading trust scores:", error);
        displayError("Error loading trust scores: " + error.message);
      }
    }

    // Lightweight check for pending penalties on page load (no transaction required)
    async function checkPendingPenaltiesOnLoad() {
      try {
        if (!factoryContract) return;

        const loanAddresses = await factoryContract.getLoans();
        let totalPendingPenalties = 0;
        let affectedLoans = 0;

        for (const loanAddress of loanAddresses) {
          try {
            const loanContract = new ethers.Contract(loanAddress, LoanAgreementABI, signer);
            
            const [borrower, startTimestamp, installmentInterval, totalInstallments, repaidAmount, principal, interestPercent] = await Promise.all([
              loanContract.borrower(),
              loanContract.startTimestamp(),
              loanContract.installmentInterval(),
              loanContract.totalInstallments(),
              loanContract.getRepaidAmount(),
              loanContract.principal(),
              loanContract.interestPercent()
            ]);

            const now = Math.floor(Date.now() / 1000);
            const startTime = parseInt(startTimestamp.toString());
            const interval = parseInt(installmentInterval.toString());
            const totalInstallmentsNum = parseInt(totalInstallments.toString());
            const repaidEther = parseFloat(ethers.formatUnits(repaidAmount, 18));
            const principalEther = parseFloat(ethers.formatUnits(principal, 18));
            const interestPercentNum = parseInt(interestPercent.toString());

            const elapsedPeriods = Math.floor((now - startTime) / interval);
            const maxPeriods = Math.min(elapsedPeriods, totalInstallmentsNum);
            
            let pendingPenaltiesForLoan = 0;

            if (maxPeriods > 0) {
              const totalAmountWithInterest = principalEther * (1 + interestPercentNum / 100);
              
              for (let i = 1; i <= maxPeriods; i++) {
                const dueTime = startTime + (i * interval);
                const expectedAmountByPeriod = (totalAmountWithInterest * i) / totalInstallmentsNum;
                
                if (now > dueTime && repaidEther < expectedAmountByPeriod) {
                  pendingPenaltiesForLoan++;
                }
              }
            }

            if (pendingPenaltiesForLoan > 0) {
              affectedLoans++;
              totalPendingPenalties += pendingPenaltiesForLoan;
            }
            
          } catch (error) {
            // Silently continue if error reading individual loan
          }
        }

        // Show subtle notification if penalties are pending
        if (totalPendingPenalties > 0) {
          const notificationMessage = `‚ö†Ô∏è ${totalPendingPenalties} trust score penalties pending across ${affectedLoans} loan(s). Click "üëÅÔ∏è Check Pending Penalties" for details.`;
          
          // Show as a warning that doesn't auto-dismiss
          setTimeout(() => {
            displayError(notificationMessage);
          }, 500);
          
          console.log(`üö® Automatic check found ${totalPendingPenalties} pending trust score penalties`);
        }
        
      } catch (error) {
        // Silently fail - this is just a convenience check
        console.log("Note: Could not automatically check pending penalties:", error.message);
      }
    }

    window.onload = init;
  </script>
</body>
</html>